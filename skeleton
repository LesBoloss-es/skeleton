#!/usr/bin/env python

import argparse
import sys

from pathlib import Path


def panic(msg: str):
    print(msg, file=sys.stderr)
    exit(2)


def fail(msg: str):
    print(msg, file=sys.stderr)
    exit(1)


TEMPLATE_DIR = Path(__file__).parent.joinpath("langs").absolute()
if not TEMPLATE_DIR.exists():
    panic(f"panic: Template directory {TEMPLATE_DIR} does not exist")


def discover_langs():
    return [path for path in TEMPLATE_DIR.iterdir() if path.is_dir()]


class Lang:
    def __init__(self, path: str):
        path = TEMPLATE_DIR.joinpath(path)
        self.path = path
        self.flavours = self.discover_flavors()

    def discover_flavors(self):
        return {file.name: file for file in self.path.iterdir() if file.is_dir()}

    def __str__(self):
        flavours = "+" + " +".join(self.flavours.keys())
        return f"lang {self.path.name} [{flavours}]"


class Template:
    def __init__(self, lang: Lang):
        self.lang = lang
        # Checking available falvours
        self.flavours = []
        self.add_flavour("default")
        # Default rendering context
        self.context = {"lang": lang.path.name, "projet_name": "new_project"}

    def add_flavour(self, name: str):
        if name not in self.lang.flavours:
            fail(f"flavour '{name}' found for {self.lang}")
        self.flavours.append(name)

    def generate(self, dest: Path):
        if not dest.exists():
            dest.mkdir()
        assert dest.is_dir()
        # If destination name seems meaningful, it may be the new project name
        if dest.name not in {".", "..", ""}:
            self.context["project_name"] = dest.name
        # Start the copy
        for flavour in self.flavours:
            self.copy_dir(self.lang.flavours[flavour], dest)

    def copy_dir(self, dir: Path, dest: Path):
        for file in dir.iterdir():
            filename = self.render(file.name, file)
            new_dest = dest.joinpath(filename)
            if file.is_file():
                self.copy_file(file, new_dest)
            elif file.is_dir():
                new_dest.mkdir()
                self.copy_dir(file, new_dest)

    def copy_file(self, file: Path, dest: Path):
        with open(file, "r") as file:
            with open(dest, "w") as dest:
                dest.write(self.render(file.read(), file, infile=True))

    def render(self, text: str, path: Path, infile=False):
        try:
            return text.format(**self.context)
        except KeyError as err:
            key, = err.args
            path = path.absolute()
            if infile:
                fail(
                    f"Could not render the content of file {path}\n"
                    f"No value found for placeholder {key}"
                )
            else:
                err_type = "dir" if path.is_dir() else "file"
                fail(
                    f"Could not render {err_type} name {text} because key {key} is "
                    f"undefined. Original file is location at {path}"
                )

    def __str__(self):
        flavours = "+".join(self.flavours)
        return f"template {self.name}+{flavours}"


def action_list(options: argparse.Namespace):
    langs = [Lang(name) for name in discover_langs()]
    langs = "  - " + "\n  - ".join([str(lang) for lang in langs])
    print(f"Available langs:\n{langs}")


def action_init(options: argparse.Namespace):
    template = Template(options.lang)
    for f in options.flavours:
        template.add_flavour(f)
    template.generate(options.dest)


parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers(required=True)

parser_init = subparsers.add_parser("init")
parser_init.add_argument(
    "-f", "--flavour", dest="flavours", action="append", default=[]
)
parser_init.add_argument("lang", type=Lang, metavar="LANG")
parser_init.add_argument("dest", type=Path, metavar="DEST")
parser_init.set_defaults(func=action_init)

parser_list = subparsers.add_parser("list")
parser_list.set_defaults(func=action_list)


if __name__ == "__main__":
    options = parser.parse_args()
    options.func(options)
